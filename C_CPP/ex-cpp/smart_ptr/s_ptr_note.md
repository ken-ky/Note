### 智能指针
+ 参考
  + [万字长文全面详解现代C++智能指针：原理、应用和陷阱](https://zhuanlan.zhihu.com/p/672745555)
<br>

#### RAII思想
+ RAII机制（`Resource Acquisition is Initialization`，资源获取即初始化）：在类的构造函数里申请资源，然后使用资源，最终在析构函数中释放资源
+ 动态内存管理：
  + `new` 在动态内存中为对象分配空间，并且返回指向该对象的指针，可以选择对对象初始化
  + `delete` 接受一个动态对象的指针，销毁该对象，并释放与之关联的内存
+ 智能指针的应用：
  + 智能指针的行为类似常规指针，**重要的区别是它负责自动释放所指向的对象** 
<br>

##### 程序对象的生存期
+ 全局对象在程序启动时分配，在程序结束时销毁。
+ 对于局部自动对象，当我们进入其定义所在的程序块时被创建，在离开块时销毁。
+ 局部static对象在第一次使用前分配，在程序结束时销毁。
+ C++还支持动态分配对象。**动态分配的对象的生存期与它们在哪里创建是无关的，只有当显式地被释放时，这些对象才会销毁。**
<br>

#### 三种智能指针

##### `shared_ptr`类
+ 底层原理：
  ```cpp
  element_type* _M_ptr; // Contained pointer
  __shared_count<_Lp> _M_refcount;  // Reference counter
  ```
  ![](https://pic2.zhimg.com/v2-1fe598431fbc3e62777050b17bc5c39b_1440w.jpg)
  + 内部维护一个引用计数，只有两个指针成员：
    + 一个是指针所管理的数据地址
    + 还有一个指针是控制块的地址，包括引用技术、`weak_ptr`计数、删除器`Deleter`、分配器`Allocator`
  + 因为不同`shared_ptr`指针需要共享相同的内存对象，因此引用计数的存储是在堆上的
+ `shared_ptr<T>`的简单实现：只实现`shared_ptr`的拷贝构造函数、析构函数和赋值运算符，引用计数只是简单用了一个`int`类型的内存空间，省略了`weak_ptr`的计数、删除器和分配器，不考虑多线程情况。要求如下：
【实现于`./simple_shared_ptr.cpp`】
  + 销毁一个`shared_ptr`时，引用计数减一
    + 引用计数为0，则删除指向实际数据的指针和指向引用计数的指针
  + 拷贝一个`shared_ptr`时，引用计数加1
  + 赋值一个`shared_ptr`时，首先递减左侧运算对象的引用计数
    + 如果引用计数变为0，则释放左侧运算对象分配的内存以及引用计数的内存
    + 然后拷贝右侧运算对象的数据指针和引用计数指针
    + 最后递增引用计数
