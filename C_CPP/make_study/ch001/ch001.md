### 《CMake构建实战：项目开发卷》备忘笔记
<br>

#### Linux 终端命令
+ `readlf` 命令：查看动态节（synamic section）
  ```sh
  $ readlf -d ./main	# -d 查看动态节
  ```
+ `ps aux | grep <process>` 捕捉某一进程

<br>

#### Linux 系统内容
+ 内存使用记录表路径 `/proc/<PID>`
  + `./smaps` 中包含程序虚拟内存空间使用情况
    + `Pss` （分摊内存）：这部分内存空间被共享进程分摊后的大小
+ 路径变量：
  + 动态链接器根据环境变量值搜索动态库：
    ```sh
    $ LD_LIBRARY_PATH=../main
    ```
  + `${HOME}` 代表 Home 目录绝对路径
  + `..._LIB_DIR` 表示库文件目录

<br>

#### C/C++ 相关内容
+ 模板类编程：
	```c++
	// 构建了一个类似数组的递归结构
	template <int N> struct Fib {
		static const int value = Fib<N - 1>::value + Fib<N - 2>::value;
	};
	
	// 设置了递归终点
	template <> struct Fib<1> {
		static const int value = 1;
	};
	
	template <> struct Fib<2> {
		static const int value = 1;
	};
	
	int fib25 = Fib<25>::value;
	```
  
<br>

#### 编译相关
+ 测量时间
  ```sh
  $ time g++ main.cpp slow.cpp
  real    0m0.895s
  user    0m0.330s
  sys     0m0.186s
  ```
+ 按需编译：避免了重复编译 `main.cpp`
  + `g++ -c`：将 `.cpp` 文件编译为 `.o` 文件
  + `g++ main.o slow.o` 将两个文件进行链接
+ 按特定 `Makefile` 编译：
  ```sh
  $ make -f Makefile0
  ```
+ 清理编译产生文件，搭配 `make clean` 使用：
  ```Makefile
  clean:
	rm *.o *.so main || true
  ```
+ 设置工作路径：
  ```Makefile
  main: main.o liba.so
	gcc main.o -o main -L. '-Wl,-R$$ORIGIN' -la
  ```
  + 其中传递了 `-R $ORIGIN` 参数，表示 `RUNPATH` 位于 “`$ORIGIN`”（程序所在目录）
  + 另外设置 `rpath` 通过 `-Wl,-rpath=$$ORIGIN`（不推荐）
