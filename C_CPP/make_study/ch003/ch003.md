### 第三章 CMake程序
`CMake` 程序根据文件名，可分为：
+ 名为 `CMakeLists.txt` 的文件：用于组织构建项目源程序的目录结构
+ 扩展名为 `.cmake` 的程序：分为脚本程序和模块程序
  + 脚本程序：使用 `cmake -P <filename>.cmake` 执行脚本程序
  + 模块程序：与目录程序都可使用 `include` 命令引用 `CMake` 模块程序

<br>

#### CMake 语法

##### 注释
+ 注释与多行注释：
  + 单行注释使用 `#` 开头的单行
  + 括号注释：`[===[]===]` 也是有效注释
    ```cmake
    #[[ 这是一个括号注释
    它可由多行文本组成
    直到遇到两个方括号 ]]
    message("a" #[=[ 程序中间也可插入一段注释]
    =] "b")
    ```
<br>

##### 参数
+ 命令参数：
  + 引号参数（quoted argument）：双引号，类似字符串【可包含换行，行末`\`可避免换行】，支持变量引用和转义字符
  + 非引号参数（unquoted argument）：未被引号包裹，不能包含任何空白符【除非转义，否则不能包含`(,),#,"",\`】
  + 括号参数（bracket argument）
+ 变量引用：`${<变量名>}` 进行传递
  + 通过 `set(<变量名> <value>)` 进行设置
  + 若变量未定义，则替换为空字符串
  + 特殊变量：
    + 缓存变量 `$CACHE{<缓存变量>}`
    + 环境变量 `$ENV{环境变量}`
+ 转义字符：较特殊的就是 `\;`（之前的例子中，非引号引用`;`间的字符串被连接，此时才会被转义）
  + 转义字符与变量：`${"\<转义字符>"}` 实际上就等价于变量 `<转义字符>`
+ 括号参数：与括号注释的区别在于没有 `#`
<br>

##### 变量
+ 变量分类
  + 普通变量：具有特定作用域
  + 缓存变量：能被缓存起来的变量，会被持久化到 `CMakeCache.txt` 中，每次 `CMake` 程序执行时，都会从被持久化的缓存文件中读取缓存变量的值【避免每次构建项目都进行耗时的部分过程获得数据】
    + `cmake -P` 执行脚本程序时，不会对缓存变量进行修改
    + 缓存变量具有全局作用域
  + 环境变量：操作系统的环境变量，对 `CMake` 进程有全局作用域
+ 变量的作用域
  + 函数作用域：用户自定义的函数命令的作用域
  + 目录作用域：对于 `CMake` 的目录程序而言，每一个目录层级，都有它的一个作用域
    + 子目录程序被执行前，会将父目录作用域中所有的变量复制一份到子目录作用域中
    + 对于 `CMake` 脚本程序而言，目录作用域相当于只有一层
+ 保留标识符：`CMake` 将以下3种形式的名称作为保留符号，自定义变量应当避开（不区分大小写）
  + 以`CMAKE_`开头的名称
  + 以`_CMAKE_`开头的名称
  + 以`_<CMake中预定义命令>`的名称
+ 预定义变量：预定义变量往往与系统配置、运行环境、构建行为、编译工具链、编程语言等信息相关（一般以`CMAKE_`开头）
  + `CMAKE_ARGC`表示CMake脚本程序在被cmake -P命令行调用执行时，命令行传递的参数个数
  + `CMAKE_ARGV<n>`表示CMake脚本程序在被命令行调用执行时，命令行传递的第`n`个参数
  + `CMAKE_COMMAND`表示CMake命令行程序所在的路径
  + `CMAKE_HOST_SYSTEM_NAME`表示宿主机操作系统（运行CMake的操作系统）名称
  + `CMAKE_SYSTEM_NAME`表示CMake构建的目标操作系统名称
  + `CMAKE_CURRENT_LIST_FILE`表示当前运行中的CMake程序对应文件的绝对路径
  + `CMAKE_CURRENT_LIST_DIR`表示当前运行中的CMake程序所在目录的绝对路径
  + `MSVC`表示在构建时CMake当前使用的编译器是否为MSVC
  + `WIN32,APPLE,UNIX`分别表示当前不同操作系统
+ 定义变量：
  + 定义普通变量：
    ```cmake
    set(<变量> <value>... [PARENT_SCOPE])
    ```
    + 变量的值可以由若干参数来提供，这些参数会被分号分隔为列表
    + 值参数也可以被省略，此时，该变量会从当前作用域中移除，相当于对该变量调用了`unset`命令
    + 还可以通过可选参数`PARENT_SCOPE`将变量定义到父级作用域中
  + 定义缓存变量：
    ```cmake
    set(<变量> <值>... CACHE <变量类型> <变量描述> [FORCE])
    ```
    + 因为缓存变量具有全局的作用域，也就不需要`PARENT_SCOPE`参数
    + 变量类型：
      |type|describe|GUI Set|
      |---|---|---|
      |`BOOL`|布尔型|选择框|
      |`FILEPATH`|文件路径型|文件对话框|
      |`PATH`|目录路径型|目录对话框|
      |`STRING`|文本型|文本或下拉选择框|
      |`INTERNAL`|内部使用（隐含设置`FORCE`参数）|不显示|
      + `FORCE`强制覆盖缓存变量值，忽略后续对该缓存变量的`set`赋值（除非设置为不存在或者参数含有`FORCE`）
      + `BOOL`型缓存变量还可以使用`option`命令定义：
        ```cmake
        option(<变量> <变量描述> [<ON|OFF>])
        ```
      + 当缓存变量是`PATH`或`FILEPATH`类型，且通过命令行为定义的变量值是一个相对路径时，`set`命令会将这个相对路径根据当前目录转换为绝对路径
    + 可以直接修改持久化缓存文件`CMakeCache.txt`的方式来定义或覆盖其值
    + `CMake`命令行工具`-D`参数也可用于定义或覆盖缓存变量值
      ```cmake
      -D <变量>:<缓存变量类型>=<value>
      -D <变量>=<value>
      ```
  + 定义环境变量：
    ```cmake
    set(ENV|{<环境变量>} [<value>])
    ```
    + 环境变量具有全局作用域，不支持使用参数列表来定义值，也没有其他元信息，因此定义环境变量的命令形式是最简单的
    + 通过`CMake`的`set`命令定义的环境变量只会影响当前的`CMake`进程，不会影响到父进程或系统的环境变量配置
<br>

##### 列表
+ 定义列表变量
  + 可以利用引号参数直接定义一个包含分号的字符串，这就是一个列表
  + `set`命令还支持指定多个作为变量值的参数，这样引号参数和非引号参数都可以使用
+ 特殊的分号：`[;]`未闭合的中括号间的分号无法分隔元素，而`[[]];`闭合的中括号后是可以的
<br>

##### 控制结构
+ `if`条件分支：
  ```cmake
  if(<条件>)
    <cmd>...
  elseif(<条件>)
    <cmd>...
  else()
    <cmd>
  endif()
  ```
+ `while`循环：
  ```cmake
  while(<条件>)
    <命令>...
  endwhile()
  ```
  + `break`与`continue`
+ `foreach`遍历循环
  + 简单列表遍历（traverse）
    ```cmake
    foreach(<循环变量> <循环项的列表>)
      <cmd>...
    endforeach()
    ```
  + 区间遍历
    ```cmake
    foreach(<循环变量> RANGE [<begin>] <end> [<step>])
    ```
  + 高级列表遍历
    ```cmake
    foreach(<循环变量> IN [LISTS [<列表变量名的列表>]] [ITEMS [<循环项的列表>]])
    ```
  + 打包遍历：类似`Python`的`zip`函数
    ```cmake
    foreach(<循环变量>... IN ZIP_LISTS <列表变量名的列表>)
    ```

##### 条件语法
+ 常量条件：
  |type|value|result|
  |---|---|---|
  |真值|`1,ON,YES,TRUE,<非零值>`（不区分大小写）|真|
  |假值|`0,OFF,NO,FALSE,"",NOTFOUND,"<str> -NOTFOUND"`|假|
+ 变量和字符串条件
  ```cmake
  if(<str|var>)
  ```
+ 逻辑运算：
  ```cmake
  if(<条件1> AND <条件2>)
  if(<条件1> OR <条件2>)
  if(NOT <条件>)
  ```
+ 单参数条件
  <img src="https://res.weread.qq.com/wrepub/CB_3300091899_5ZcAMEFnP5q201Hc9af6.jpg">
+ 双参数条件
  + 数值比较
    ```cmake
    if(<str|var> LESS <str|var>)
    if(<str|var> GREATER <str|var>)
    if(<str|var EQUAL <str|var>>)
    if(<str|var> LESS_EQUAL <str|var>)
    if(<str|var> GREATER_EQUAL <str|var>)
    ```
  + 字符串比较
    ```cmake
    if(<str|var> STRLESS <str|var>)
    if(<str|var> STRGREATER <str|var>)
    if(<str|var> STREQUAL <str|var>)
    if(<str|var> STRLESS_EQUAL <str|var>)
    if(<str|var> STRGREATER_EQUAL <str|var>)
    ```
  + 字符串匹配
    ```cmake
    if(<str|var> MATCHES <正则表达式>)
    ```
  + 版本号比较
    ```cmake
    if(<str|var> VERSION_LESS <str|var>)
    if(<str|var> VERSION_GREATER <str|var>)
    if(<str|var> VERSION_EQUAL <str|var>)
    if(<str|var> VERSION_LESS_EQUAL <str|var>)
    if(<str|var> VERSION_GREATER_EQUAL <str|var>)
    ```
    + 版本号格式：`主版本号[.次版本号[.补丁版本号]]`（版本号每个部分都是整数，被省略部分默认为 0）
  + 列表元素判断
    ```cmake
    if(<str|var> IN_LIST <list_var>)
    ```
+ 条件语法求值的优先级自高到低依次为：
  + 最内层括号中的条件
  + 单参数条件
  + 双参数条件
  + `NOT`逻辑条件
  + `AND`逻辑条件
  + `OR`逻辑条件
+ 变量展开：一般将条件语法中直接访问变量值的这种行为称为`variable expansion`
  + 引号参数和括号参数中的变量都不会被展开
  + 变量展开只适用于普通变量，缓存变量和环境变量需要使用特定的`$CACHE{...}`和`$ENV{...}`进行访问
<br>

##### 命令定义
+ 宏定义：
  ```cmake
  macro(<宏名> [<arg1>...])
    <cmd>...
  endmacro()
  ```
  + 宏包含的命令序列仅在宏被调用时执行，且执行时不产生额外的作用域
+ 函数定义
  ```cmake
  function(<函数名> [<arg1>...])
    <cmd>...
  endfunction()
  ```
  + 函数内部会产生新作用域，使用`set`命令指定参数`PARENT_SCOPE`，使得上层作用域可以作用变量
+ 参数的访问
  + 引用形式参数（`formal parameter`）：宏定义时指定的参数
  + 列表或索引访问参数：`CMake`支持使用列表或索引来访问某个参数
    + `${ARGC}`表示参数个数
    + `${ARGV}`表示完整的实参列表，其元素为用户传递的每个参数
      + `${ARGV0},${ARGV1}...`依次表现几个实参的值
    + `${ARGN}`表示无对应形式参数的实参列表，其元素为第`(N+1)`个用户传递的参数
+ 参数的设计与解析
  + 参数设计规范
    + 开关选项（`option`）：调用者可以通过指定该参数来启用某个选项【类似布尔值】
    + 单值参数关键字（`one-value`）：它的后面会且仅跟随一个参数值【相当于键值对】
    + 多值参数关键字（`multi-value keyword`）：后面可以跟随多个参数值【相当于接收一个列表参数】
  + `cmake_parse_argments`的通用形式
    + 在函数或宏中均可使用的通用形式，但它无法解析一些包含特殊符号的单值参数
      ```cmake
      cmake_parse_argments(
        <结果变量前缀名>
        <开关选项关键字列表> <单值参数关键字列表> <多值参数关键字列表>
        <将被解析的参数>...
      )
      ```
      + 它通过指定的三种关键字的列表解析传递的`<将被解析参数>`将每种关键字对应的参数值存放在一些结果变量中
      + 这些结果变量的名称以`<结果变量前缀名>`加一个下划线`_`作为前缀，后面则是对应关键字名称
    + 另一形式不存在上述缺陷，但只支持在函数中使用【针对函数优化形式】
      ```cmake
      cmake_parse_argments(
        PARSE_ARGV <N>
        <结果变量前缀名>
        <开关选项关键字列表> <单值参数关键字列表> <多值参数关键字列表>
      )
      ```
      + `<N>`是一个从 0 开始的整数，表示从函数的第几个实参开始解析参数【前`N`个参数都是不需要关键字、需要调用者直接依次传参的参数】
  + 特殊的结果变量：`cmake_parse_argments`除了将解析的参数存放到对应关键字的结果变量中，还会将一些**未能解析的参数、没有提供值**的关键字等信息存放到另外两个特殊的结果变量中：
    + `<结果变量前缀名>_UNPARSED_ARGMENTS`：存放所有未能解析到某一关键字中的实参值
    + `<结果变量前缀名>_KEYWORDS_MISSING_VALUES`：存放所有未提供实参值的关键字名称
    【这两个结果变量存放的值可能有多个，因此均为列表】
+ 宏和函数的区别
  + 执行上下文和作用域：
    + 宏与调用上下文共享作用域
    + 函数执行时，控制流会从调用上下文转移到函数体内
    + 命令`return`可结束当前函数、当前`CMake`目录或文件的执行
      + 宏内调用`return`，宏所在的函数、`CMake`目录或文件也会被中断
  + 定义外部可见的变量：定义变量的区别**正是作用域导致的**
    + 宏内定义：作用域正是上下文层
    + 函数内定义：需要`set`指定`PARENT_SCOPE`参数
    【`CMake`中没有“返回值”，`return`只会结束当前作用域上下文】
  + 预定义变量：函数体可以通过访问`CMake`预定义的变量，获取关于当前执行中的函数信息
    + `CMAKE_CURRENT_FUNCTION`：当前函数名称
    + `CMAKE_CURRENT_FUNCTION_LIST_DIR`：定义当前函数的`CMake`程序文件所在的目录
    + `CMAKE_CURRENT_FUNCTION_LIST_FILE`：定义当前函数的`CMake`程序文件的完整路径
    + `CMAKE_CURRENT_FUNCTION_LIST_LINE`：当前函数在`CMake`程序文件中定义时对应代码行行号
  + 参数访问：宏和函数均可以通过**引用形式参数、参数列表或索引**等方式来访问实际参数（二者表面类似，实际上大有不同）
    + 函数中，包括形式参数、`ARGC`、`ARGV`、`ARGN`等都是真正的`CMake`变量，且定义在当前函数作用域内
    + 在宏中，由于没有作用域的缘故，因此这些用于访问的符号并非真正的变量
      + 宏的处理：将引用这些符号的地方直接进行文本替换【不能将这些参数作为变量条件用于条件语法，也不能利用变量嵌套访问这些符号】
      ```cmake
      macro(my_macro p)
        message("-- my_macro --")
        if(p)
          message("p is true")
        endif()
        set(i 1)
        message("ARGV i: ${ARGV${i}}")
      endmacro()

      function(my_func p)
        message("-- my_func --")
        if(p)
          message("p is true")
        endif()
        set(i 1)
        message("ARGV i: ${ARGV${i}}")
      endfunction()

      my_macro(ON x)
      my_func(ON x)
      ```